import json
from typing import Dict, Any, List
from datetime import datetime
import graphviz

class ReportGenerator:
    def __init__(self):
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def generate_markdown_report(self, state: Dict[str, Any]) -> str:
        report = f"""# GapForge Report
**Privacy-Preserving Multi-Agent Research Gap Analysis**

Generated: {self.timestamp}  
Protocol: MCP-DP-v1.0  
Privacy Level: Differential Privacy (ε=1.0)

---

## Executive Summary

This report presents research gaps identified through multi-agent debate, novel hypotheses, and 24-hour buildable MVP proposals. The analysis was conducted using a privacy-preserving architecture with simulated Model Context Protocol (MCP) and differential privacy protections.

**Documents Analyzed:** {len(state.get('documents', []))}  
**Gaps Identified:** {len(state.get('gaps', []))}  
**Hypotheses Generated:** {len(state.get('hypotheses', []))}  
**Agent Iterations:** {state.get('iteration', 0)}  
**MCP Messages Exchanged:** {len(state.get('mcp_messages', []))}

---

## Identified Research Gaps

"""
        
        for i, gap in enumerate(state.get('gaps', []), 1):
            report += f"{i}. {gap}\n\n"
        
        report += "\n---\n\n## Multi-Agent Debates\n\n"
        
        for i, debate in enumerate(state.get('debates', [])[:3], 1):
            report += f"### Debate {i}: {debate['gap'][:100]}...\n\n"
            report += f"**Pro Arguments:**\n{debate['pro_arguments']}\n\n"
            report += f"**Critical Challenges:**\n{debate['con_arguments']}\n\n"
            report += "---\n\n"
        
        report += "\n## Top Hypotheses & MVP Proposals\n\n"
        
        for i, hypo in enumerate(state.get('final_hypotheses', []), 1):
            score = hypo.get('score', 0)
            report += f"### Hypothesis {i} (Score: {score:.1f}/10)\n\n"
            report += f"**Gap Addressed:** {hypo['gap']}\n\n"
            report += f"**Proposal:**\n{hypo['proposal']}\n\n"
            report += "---\n\n"
        
        report += "\n## Privacy & MCP Analysis\n\n"
        report += f"""This analysis utilized:\n
- **Differential Privacy**: Embeddings were perturbed using Laplace mechanism (ε=1.0)
- **MCP Protocol**: Agents communicated via secure context envelopes
- **Privacy-Preserving Debates**: {len(state.get('mcp_messages', []))} MCP messages exchanged
- **Reasoning Trace**: {len(state.get('reasoning_trace', []))} agent actions logged

All data transfers between agents followed the MCP-DP-v1.0 protocol, ensuring privacy guarantees throughout the analysis pipeline.
"""
        
        report += "\n## Recommended Next Steps\n\n"
        report += """1. **Immediate Action**: Implement the top-scored hypothesis as a 24-hour MVP
2. **Privacy Validation**: Test differential privacy guarantees with sensitivity analysis
3. **Gap Refinement**: Conduct deeper literature review on identified gaps
4. **Prototype Development**: Build benchmark datasets or evaluation tools
5. **Ethical Review**: Assess privacy and safety implications before deployment

"""
        
        report += "\n---\n\n*Generated by ContextForge - Privacy-Preserving Multi-Agent Gap Detector*\n"
        
        return report
    
    def generate_json_artifact(self, state: Dict[str, Any]) -> Dict[str, Any]:
        artifact = {
            "metadata": {
                "generated_at": self.timestamp,
                "protocol": "MCP-DP-v1.0",
                "privacy_epsilon": 1.0,
                "iterations": state.get('iteration', 0)
            },
            "gaps": state.get('gaps', []),
            "hypotheses": [
                {
                    "gap": h['gap'],
                    "proposal": h['proposal'],
                    "score": h.get('score', 0),
                    "iteration": h.get('iteration', 0)
                }
                for h in state.get('final_hypotheses', [])
            ],
            "debates": [
                {
                    "gap": d['gap'],
                    "pro_arguments": d['pro_arguments'],
                    "con_arguments": d['con_arguments']
                }
                for d in state.get('debates', [])[:3]
            ],
            "mcp_messages": state.get('mcp_messages', []),
            "reasoning_trace": state.get('reasoning_trace', [])
        }
        
        return artifact
    
    def generate_reasoning_graph(self, state: Dict[str, Any], output_path: str = "reasoning_trace") -> str:
        dot = graphviz.Digraph(comment='Agent Reasoning Trace', format='png')
        dot.attr(rankdir='TB', size='10,10')
        
        dot.attr('node', shape='box', style='rounded,filled', fillcolor='lightblue')
        
        trace = state.get('reasoning_trace', [])
        
        for i, step in enumerate(trace):
            agent = step['agent']
            action = step['action']
            iteration = step.get('iteration', 0)
            
            node_id = f"{agent}_{i}"
            label = f"{agent}\n{action}\nIteration: {iteration}"
            
            if agent == "GapDetector":
                dot.node(node_id, label, fillcolor='#FFE5B4')
            elif agent == "Debater":
                dot.node(node_id, label, fillcolor='#B4E5FF')
            elif agent == "HypoGenerator":
                dot.node(node_id, label, fillcolor='#B4FFB4')
            elif agent == "Evolver":
                dot.node(node_id, label, fillcolor='#FFB4E5')
            else:
                dot.node(node_id, label, fillcolor='#E5E5E5')
            
            if i > 0:
                prev_node = f"{trace[i-1]['agent']}_{i-1}"
                dot.edge(prev_node, node_id)
        
        try:
            dot.render(output_path, cleanup=True)
            return f"{output_path}.png"
        except Exception as e:
            return f"Graph generation failed: {str(e)}"
    
    def save_report(self, state: Dict[str, Any], output_dir: str = "outputs") -> Dict[str, str]:
        import os
        os.makedirs(output_dir, exist_ok=True)
        
        markdown_report = self.generate_markdown_report(state)
        json_artifact = self.generate_json_artifact(state)
        
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        md_path = f"{output_dir}/gapforge_report_{timestamp_str}.md"
        json_path = f"{output_dir}/gapforge_artifact_{timestamp_str}.json"
        graph_path = f"{output_dir}/reasoning_trace_{timestamp_str}"
        
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(markdown_report)
        
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(json_artifact, f, indent=2, ensure_ascii=False)
        
        graph_file = self.generate_reasoning_graph(state, graph_path)
        
        return {
            "markdown": md_path,
            "json": json_path,
            "graph": graph_file
        }
